%!TEX root = foo-thesis.tex

\chapter{Postprocessing}
\label{chap:postproc}

Die Nachprozessierung findet statt, nachdem vom jeweiligen Ansatz alle Punkte einer Klasse zugewiesen wurden. Da dies eine verhältnismäßig simple Aufgabe ist, findet sich die Implementierung in denselben Python-Skripten, welche auch die Funktionalität zum Modelltraining und -test des \textit{Feature-Extraction}-Ansatzes beinhalten. Die Grundidee ist, Klassen von denjenigen Punkten noch einmal zu ändern, bei denen eine andere Klasse aufgrund der unmittelbaren Nachbarklassen wahrscheinlich ist. Dies geschieht in zwei Richtungen, wofür sequentiell zwei Iterationen notwendig sind. In beiden Richtungen wird eine Punktenachbarschaft im Scale von 7,5$cm$ betrachtet, die sich als geeignet herausgestellt hat. Auch hier wird für den effizienten Zugriff auf die Nachbarn ein zuvor für die Punktwolke ersteller \textit{k-d}-Baum genutzt, der an dieser Stelle entsprechend in Python implementiert ist. \\\\
Die erste Richtung besteht darin, Klassen-Außenseitern die Standardklasse der gewöhnlichen Straße zuzuweisen. Darunter fallen Punkte, die momentan nicht Straße sind, aber auch nicht genügend Punkte ihrer Klasse in unmittelbarer Umgebung haben. Für jede der betrachteten Objektklassen wird angenommen, aus mehr als einigen wenigen Punkten zu bestehen. Solche Klassifizierungen werden daher als eher zufälliges \textit{Rauschen} interpretiert und versucht zu beseitigen. \\
Der Klassenwechsel wird genau dann durchgeführt, wenn im Scale nicht mindestens 10\% der Punkte dieselbe Klasse wie der Ursprungspunkt besitzen. Dies funktioniert gut für Klassen, die wie der kugelförmige Scale auch rundlich sind, darunter Gullys und Schlaglöcher. Für Flickstellen kann dies problematischer sein, da diese meist dünn und linienartig verlaufen. Die Auswirkungen dieser Verarbeitung auf die verschiedenen Klassen finden sich in Kapitel \ref{chap:eval}. \\\\
Die andere Richtung behandelt Straßenpunkte, die inmitten von Nicht-Straßenpunkten liegen. Bei genügend großem Anteil von letzterer Gruppe nimmt der Punkt die häufigste Nicht-Straßenklasse seiner Nachbarschaft an. Auf diese Weise sollen zum Beispiel Schlaglöcher innen aufgefüllt oder die Mitte von Gullys ergänzt werden, wenn sie etwa wegen eines zu geringen Scales nicht als eben jene Klassen erkannt wurden. \\
Zunächst wird dazu über die als gewöhnliche Straße klassifizierten Punkte iteriert und jeweils der Prozentsatz an Punkten im Scale ermittelt, der nicht Straße ist. Übersteigt dieser die Schwelle von 50\%, wird dem Ursprungspunkt die häufigste Nicht-Straßenklasse seiner Nachbarschaft zugeteilt. Für eine weitere Zeitersparnis wird diese Iteration letztlich nur auf denjenigen Straßenpunkten ausgeführt, die in der Nachbarschaft mindestens eines Nicht-Straßenpunktes liegen, da auch nur jene für einen Klassenwechsel dieser Richtung in Frage kommen. Wegen des großen Überwiegens der Straßenpunkte sinkt durch diesen Schritt ihre noch zu betrachtende Menge beträchtlich. \\\\
Dieses \textit{Postprocessing} soll nur vermeintlich eindeutige Fehlklassifzierungen ausbessern. Den ursprünglichen Klassifizierungen, ob durch \texttt{PointNet} oder den eigenen Ansatz ermittelt, wird dabei wegen ihrer tiefergehenden Begründungen für die Entscheidung eine höhere Legitimation zugestanden. Daher wird die auf den erläuterten Heuristiken beruhende Nachverarbeitung mit eher zurückhaltenden Parametern ausgeführt, obwohl dies unter Umständen zur Beibehaltung von Außenseiterpunkten oder Straßenpunkten inmitten anderer Klassen führt.